Основные типы сигналов:

    SIGINT (2): Прерывание работы процесса (например, через Ctrl+C в терминале).
    SIGTERM (15): Окончание работы процесса (обычно используется для вежливого завершения процесса).
    SIGKILL (9): Принудительное завершение процесса. Процесс не может перехватить или игнорировать этот сигнал.
    SIGSTOP (19): Приостановка процесса.
    SIGCONT (18): Возобновление выполнения приостановленного процесса.
    SIGSEGV (11): Ошибка сегментации (сигнал, посылаемый процессу при обращении к недопустимой памяти).
    SIGUSR1 и SIGUSR2: Пользовательские сигналы, которые могут быть использованы для конкретных целей.

Использование: kill -NAMESIG PID


Важные характеристики процесса:

    PID (Process ID): Уникальный идентификатор процесса.
    PPID (Parent Process ID): Идентификатор родительского процесса.
    Состояние процесса: Процесс может находиться в одном из нескольких состояний, таких как:
        R (Running): Процесс выполняется или готов к выполнению.
        S (Sleeping): Процесс спит, ожидая события.
        Z (Zombie): Процесс завершен, но его родительский процесс не получил информацию о завершении.
        T (Stopped): Процесс остановлен.

1) Ф-я signal используется для того, чтобы перехватывать сигнал и затем что-то делать (сигнал 9 перехватить невозможно)
Синтаксис: void (*signal(int signum, void (*handler)(int)))(int);

2) Ф-я sigemptyset используется для инициализации набора сигналов, тоесть она очищает все биты в структуре, представляющей набор сигналов 
Синтаксис: int sigemptyset(sigset_t *set);
set — это указатель на переменную типа sigset_t, которая представляет набор сигналов.
{
	sigset_t set;
	sigemptyset(&set);
}

3) Ф-я sigaddset добавляет указанный сигнал в набор сигналов. Это полезно, если нужно управлять набором сигналов (например, блокировать
 несколько сигналов одновременно)
Синтаксис: int sigaddset(sigset_t *set, int signum);
set — указатель на набор сигналов.
signum — это сигнал, который нужно добавить в набор.
Полный пример:
{
	sigset_t set; // создали структуру
	sigemptyset(&set); // очистили ее
	sigaddset(&set, SIGINT); // добавили сигнал 1
	sigaddset(&set, SIGTERM); // добавили сигнал 2
}
    ; set.mask используется для блокировки сигналов, например:
    sigemptyset(&set.sa_mask)
    sigaddset(&set.sa_mask, SIGINT); // Сигнал ctrl+c будет заблокирован


4) Ф-я sigaction является более мощной и гибкой альтернативой signal(). Она позволяет более точно контролировать поведение процесса при получении
сигнала, включая возможность блокировки сигналов во время обработки, а также настройку доп. параметров
Синтаксис: int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
signum — это идентификатор сигнала, с которым будет работать функция.
act — указатель на структуру sigaction, которая определяет обработчик и другие параметры для сигнала.
oldact — если не NULL, в эту структуру будет записана старая информация о обработчике сигнала.
Структура sigaction:

struct sigaction {
    void (*sa_handler)(int);      // Указатель на обработчик сигнала
    sigset_t sa_mask;             // Множество сигналов, которые должны быть заблокированы во время обработки сигнала
    int sa_flags;                 // Флаги, определяющие поведение обработки сигнала
    void (*sa_restorer)(void);    // Устаревший параметр, обычно NULL
};
Пример использования:
void handler(int signum) {
    printf("Получен сигнал %d, обработчик вызван\n", signum);
    exit(0);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handler;  // Устанавливаем обработчик
    sigemptyset(&sa.sa_mask);  // В процессе обработки сигнала не блокировать другие сигналы
    sa.sa_flags = 0;           // Стандартные флаги

    sigaction(SIGINT, &sa, NULL);  // Устанавливаем обработчик для SIGINT

    while(1) {
        printf("Работаю...\n");
        sleep(1); // Печатаем "Работаю..." каждую секунду
    }
    return 0;
}

В этом примере мы настроили обработчик для сигнала SIGINT. Когда процесс получит SIGINT (например, через Ctrl+C), будет вызвана
 функция handler(), которая выведет сообщение и завершит программу.

Отличия от signal():

    sigaction() позволяет блокировать другие сигналы во время обработки текущего сигнала с помощью поля sa_mask.
    В sigaction() можно использовать флаги, такие как SA_RESTART (для автоматического перезапуска системных вызовов после сигнала).
    sigaction() дает более гибкое управление поведением сигнала.