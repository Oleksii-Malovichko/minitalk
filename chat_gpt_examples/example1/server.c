
// Для создания клиента и сервера, которые будут обмениваться сообщениями с использованием сигналов в Linux, необходимо внимательно учитывать детали работы с сигналами и обработки данных. Вот как можно разработать такой алгоритм.

// Алгоритм для клиента и сервера
// Шаг 1: Сервер
// Запуск сервера:

// Сервер должен сначала вывести свой PID, который будет использован клиентом для отправки сообщений.
// Обработка сигналов:

// Сервер будет обрабатывать два сигнала: SIGUSR1 и SIGUSR2, которые будут отвечать за передаваемые данные.
// Когда сервер получает сигнал, он должен интерпретировать его как информацию:
// SIGUSR1 — означает бит 0.
// SIGUSR2 — означает бит 1.
// Биты должны собираться в байты, а затем байты в строку.
// Получение данных:

// Сервер должен ожидать сигналов, и когда получает их, он сохраняет соответствующие биты.
// После получения полного сообщения (или при получении сигнала конца передачи, например, специального символа), сервер должен вывести полученную строку.
// Обработка ошибок:

// В случае ошибок, например, превышения времени ожидания, сервер должен корректно завершить работу или перезапустить.
// Шаг 2: Клиент
// Запуск клиента:

// Клиент получает два параметра: PID сервера и строку для отправки.
// Клиент должен использовать kill() для отправки сигналов серверу.
// Отправка строки:

// Для каждой буквы строки клиент преобразует ее в биты.
// Для каждого бита отправляется соответствующий сигнал:
// SIGUSR1 — если бит равен 0.
// SIGUSR2 — если бит равен 1.
// После отправки всех битов, клиент может отправить сигнал, например, SIGUSR1 или SIGUSR2, чтобы сигнализировать о завершении.
// Обработка ошибок:

// Клиент должен проверить правильность переданных аргументов и правильно обработать ошибки, такие как невозможность отправить сигнал или неправильный PID.
// Алгоритм:
// Сервер:

// Печатает свой PID.
// Устанавливает обработчик сигналов для SIGUSR1 и SIGUSR2.
// При получении сигнала анализирует бит и формирует строку.
// По завершении (или по получению специального сигнала) выводит строку и возвращается в ожидание следующего клиента.
// Клиент:

// Получает PID сервера и строку для отправки.
// Преобразует строку в биты и отправляет сигналы.
// Может сигнализировать о завершении.
// Пример кода (Один из подходов)
// Сервер:

#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handler(int signum) {
    static int bit_count = 0;
    static char byte = 0;

    if (signum == SIGUSR1) {
        byte = byte << 1;  // Сдвиг влево
    } else if (signum == SIGUSR2) {
        byte = (byte << 1) | 1;  // Сдвиг влево и установка младшего бита
    }
    
    bit_count++;

    if (bit_count == 8) {
        putchar(byte);
        bit_count = 0;
        byte = 0;
    }
}

int main() {
    printf("Server PID: %d\n", getpid());
    struct sigaction sa;
    sa.sa_handler = handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);

    while (1) {
        pause();  // Ожидаем сигналы
    }

    return 0;
}